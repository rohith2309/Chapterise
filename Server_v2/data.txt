The following content is providedunder a Creative Commons license.Your support will help MIT OpenCourseWare continueto offer high quality educational resources for free.To make a donation or view additional materialsfrom hundreds of MIT courses, visit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: Hi.I'm Srini Devadas.I'm a professor of electrical engineering and computerscience.I'm going to be co-lecturing 6.006-- Introductionto Algorithms-- this term with professor Erik Domane.Eric, say hi.ERIK DOMANE: Hi. [LAUGHTER]PROFESSOR: And we hope you're goingto have a fun time in 6.006 learninga variety of algorithms.What I want to do today is spend literally a minute or soon administrative details, maybe even less.What I'd like to do is to tell youto go to the website that's listed up there and read it.And you'll get all information youneed about what this class is about from a standpointof syllabus; what's expected of you; the problem setschedule; the quiz schedule; and so on and so forth.I want to dive right in and tell you about interesting things,like algorithms and complexity of algorithms.I want to spend some time giving youan overview of the course content.And then we're going to dive rightin and look at a particular problem of peakfinding-- both the one dimensional version and a twodimensional version-- and talk about algorithms to solvethis peak finding problem-- both varieties of it.And you'll find that there's reallya difference between these various algorithmsthat we'll look at in terms of their complexity.And what I mean by that is you'regoing to have different run times of these algorithmsdepending on input size, based on howefficient these algorithms are.And a prerequisite for this class is 6.042.And in 6.042 you learned about asymptotic complexity.And you'll see that in this lecturewe'll analyze relatively simple algorithms todayin terms of their asymptotic complexity.And you'll be able to compare and saythat this algorithm is fasten this other one-- assumingthat you have large inputs-- because it'sasymptotically less complex.So let's dive right in and talk about the class.So the one sentence summary of this classis that this is about efficient proceduresfor solving problems on large inputs.And when I say large inputs, I mean thingslike the US highway system, a mapof all of the highways in the United States;the human genome, which has a billion lettersin its alphabet; a social network responding to Facebook,that I guess has 500 million nodes or so.So these are large inputs.Now our definition of large has really changed with the times.And so really the 21st century definition of largeis, I guess, a trillion.Right?Back when I was your age large was like 1,000. [LAUGHTER]I guess I'm dating myself here.Back when Eric was your age, it was a million.Right? [LAUGHTER]But what's happening really the world is moving faster,things are getting bigger.We have the capability of computing on large inputs,but that doesn't mean that efficiencyisn't of paramount concern.The fact of matter is that you can, maybe,scan a billion elements in a matter of seconds.But if you had an algorithm that required cubic complexity,suddenly you're not talking about 10 raised to 9,you're talking about 10 raised to 27.And even current computers can't reallyhandle those kinds of numbers, so efficiency is a concern.And as inputs get larger, it becomes more of a concern.All right?So we're concerned about----efficient procedures-- for solving large scale problemsin this class.And we're concerned about scalability,because-- just as, you know, 1,000was a big number a couple of decades ago,and now it's kind of a small number-- it'squite possible that by the time you guys are professorsteaching this class in some universitythat a trillion is going to be a small number.And we're going to be talking about-- I don't know--10 raised to 18 as being somethingthat we're concerned with from a standpoint of a common caseinput for an algorithm.So scalability is important.And we want to be able to track how our algorithms are goingto do as inputs get larger and larger.You going to learn a bunch of different data structures.We'll call them classic data structures,like binary search trees, hash tables-- thatare called dictionaries in Python-- and datastructures-- such as balanced binary search trees-- thatare more efficient than just the regular binary search trees.And these are all data structuresthat were invented many decades ago.But they've stood the test of time,and they continue to be useful.We're going to augment these data structures in various waysto make them more efficient for certain kinds of problems.And while you're not going to be doing a whole lot of algorithmdesign in this class, you will bedoing some design and a whole lot of analysis.The class following this one, 6.046 Designing Analysisof Algorithms, is a class that youshould take if you like this one.And you can do a whole lot more design of algorithms in 6.046.But you will look at classic data structuresand classical algorithms for these data structures,including things like sorting and matching, and so on.And one of the nice things about this classis that you'll be doing real implementations of these datastructures and algorithms in Python.And in particular are each of the problemsets in this class are going to have both a theorypart to them, and a programming part to them.So hopefully it'll all tie together.The kinds of things we're going to be talking about in lecturesand recitations are going to be directly connectedto the theory parts of the problem sets.And you'll be programming the algorithms that we talk aboutin lecture, or augmenting them, running them.Figuring out whether they work well on large inputs or not.So let me talk a little bit about the modulesin this class and the problem sets.And we hope that these problem setsare going to be fun for you.And by fun I don't mean easy.I mean challenging and worthwhile, so at the end of ityou feel like you've learned something,and you had some fun along the way.All right?So content wise----we have eight modules in the class.Each of which, roughly speaking, hasa problem set associated with it.The first of these is what we call algorithmic thinking.And we'll kick start that one today.We'll look at a particular problem, as I mentioned,of peak finding.And as part of this, you're goingto have a problem set that's going to go out today as well.And you'll find that in this problem setsome of these algorithms I talk about today willbe coded in Python and given to.A couple of them are going to have bugs in them.You'll have to analyze the complexity of these algorithms;figure out which ones are correct and efficient;and write a proof for one of them.All right?So that's sort of an example problem set.And you can expect that most of the problem setsare going to follow that sort of template.All right.So you'll get a better sense of thisby the end of the day today for sure.Or a concrete sense of this, because we'llbe done with lecture and you'll see your first problem set.We're going to be doing a module on sorting and trees.Sorting you now about, sorting a bunch of numbers.Imagine if you had a trillion numbersand you wanted to sort them.What kind of algorithm could use for that?Trees are a wonderful data structure.There's different varieties, the most common being binary trees.And there's ways of doing all sorts of things,like scheduling, and sorting, using various kinds of trees,including binary trees.And we have a problem set on simulating a logic networkusing a particular kind of sorting algorithm in a datastructure.That is going to be your second problem set.And more quickly, we're going to have modules on hashing,where we do things like genome comparison.In past terms we compared a human genome to a rat genome,and discovered they were pretty similar.99% similar, which is kind of amazing.But again, these things are so large that youhave to have efficiency in the comparison methodsthat you use.And you'll find that if you don't get the complexity lowenough, you just won't be able to complete--your program won't be able to finish running within the timethat your problem set is do.Right?Which is a bit of a problem.So that's something to keep in mind as you test your code.The fact is that you will get large inputs to run your code.And you want to keep complexity in mindas you're coding and thinking about the pseudocode,if you will, of your algorithm itself.We will talk about numerics.A lot of the time we talk about such large numbersthat 32 bits isn't enough.Or 64 bits isn't enough to represent these numbers.These numbers have thousands of bits.A good example is RSA encryption,that is used in SSL, for example.And when you go-- use https on websites,RSA is used at the back end.And typically you work with prime numbersthat are thousands of bits long in RSA.So how do you handle that?How does Python handle that?How do you write algorithms that candeal with what are called infinite precision numbers?So we have a module on numerics in the middle of the term thattalks about that.Graphs, really a fundamental data structurein all of computer science.You might have heard of the famous Rubik's cube assignmentfrom .006 a 2 by 2 by 2 Rubik's cube.What's the minimum number of movesnecessary to go from a given starting configurationto the final end configuration, where all of the faces-- eachof the faces has uniform color?And that can be posed as a graph problem.We'll probably do that one this term.In previous terms we've done other thingslike the 15 puzzle.And so some of these are tentative.We definitely know what the first problem set is like,but the rest of them are, at this moment, tentative.And to finish up shortest paths.Again in terms past we've asked youto write code using a particular algorithm thatfinds the shortest path from Caltech to MIT.This time we may do things a little bit differently.We were thinking maybe we'll give you a street map of Bostonand go figure out if Paul Revere usedthe shortest path to get to where he was going,or things like that.We'll try and make it fun.Dynamic programming is an important algorithm designtechnique that's used in many, many problems.And it can be used to do a variety of things, includingimage compression.How do you compress an image so the number of pixelsreduces, but it still looks like the imagethat you started out with, that had many more pixels?All right?So you could use dynamic programming for that.And finally, advanced topics, complexity theory, researchand algorithms.Hopefully by now-- by this time in the course,you have been sold on algorithms.And most, if not all of you, wouldwant to pursue a carrier in algorithms.And we'll give you a sense of what else is there.We're just scratching the surface in this class,and there's many, many classes that you can possiblytake if you want to continue in-- to learn about algorithms,or to pursue a career in algorithms.All right?So that's the story of the class,or the synopsis of the class.And I encourage you to go spend a few minutes on the website.In particular please read the collaboration policy, and geta sense of what is expected of you.What the rules are in terms of doing the problem sets.And the course grading break down,the grading policies are all listed on the website as well.All right.OK.So let's get started.I want to talk about a specific problem.And talk about algorithms for a specific problem.We picked this problem, because it's so easy to understand.And they're fairly straightforward algorithmsthat are not particularly efficient to solvethis problem.And so this is a, kind of, a toy problem.But like a lot of toy problems, it'svery evocative in that it points out the issues involvedin designing efficient algorithms.So we'll start with a one dimensionalversion of what we call peak finding.And a peak finder is something in the one dimensional case.Runs on an array of numbers.And I'm just putting----symbols for each of these numbers here.And the numbers are positive, negative.We'll just assume they're all positive,it doesn't really matter.The algorithms we describe will work.And so we have this one dimensional arraythat has nine different positions.And a through i are numbers.And we want to find a peak.And so we have to define what we mean by a peak.And so, in particular, as an example,position 2 is a peak if, and onlyif, b greater than or equal to a, and b greater than or equalto c.So it's really a very local property correspondingto a peak.In the one dimensional case, it's trivial.Look to your left.Look to your right.If you are equal or greater than both of the elementsthat you see on the left and the right, you're a peak.OK?And in the case of the edges, you onlyhave to look to one side.So position 9 is a peak if i greater than or equal to h.So you just have to look to your left there,because you're all the way on the right hand side.All right?So that's it.And the statement of the problem, the one dimensionalversion, is find the peak if it exists.All right?That's all there is to it.I'm going to give you a straightforward algorithm.And then we'll see if we can improve it.All right?You can imagine that the straightforward algorithm issomething that just, you know, walks across the array.But we need that as a starting point for building somethingmore sophisticated.So let's say we start from left and allwe have is one traversal, really.So let's say we have 1, 2, and then wehave n over 2 over here correspondingto the middle of this n element array.And then we have n minus 1, and n.What I'm interested in doing is, not onlycoming up with a straightforward algorithm,but also precisely characterizingwhat its complexity is in relationto n, which is the number of inputs.Yeah?Question?AUDIENCE: Why do you say if it existswhen the criteria in the [INAUDIBLE]guarantees [INAUDIBLE]?PROFESSOR: That's exactly right.I was going to get to that.So if you look at the definition of the peak,then what I have here is greater than or equal to.OK?And so this-- That's a great question that was asked.Why is there "if it exists" in this problem?Now in the case where I have greater than or equal to,then-- this is a homework question for you,and for the rest of you-- argue that any array will alwayshave a peak.OK?Now if you didn't have the greater than or equal to,and you had a greater than, then can you make that argument?No, you can't.Right?So great question.In this case it's just a question--You would want to modify this problemstatement to find the peak.But if I had a different definition of a peak-- and thisis part of algorithmic thinking.You want to be able to create algorithms that are general,so if the problem definition changes on you,you still have a starting point to go attackthe second version of the problem.OK?So you could eliminate this in the caseof the greater than or equal to definition.The "if it exists", because a peak will always exist.But you probably want to argue that whenyou want to show the correctness of your algorithm.And if in fact you had a different definition,well you would have to create an algorithm that tells youfor sure that a peak doesn't exist, or finda peak if it exists.All right?So that's really the general case.Many a time it's possible that you're asked to do something,and you can't actually give an answer to the question,or find something that satisfies all the constraints required.And in that case, you want to be able to put up your handand say, you know what?I searched long and hard.I searched exhaustively.Here's my argument that I searched exhaustively,and I couldn't find it.Right?If you do that, you get to keep your job.Right?Otherwise there's always the casethat you didn't search hard enough.So it's nice to have that argument.All right?Great.Thanks for the question.Feel free to interrupt.Raise your hand, and I'm watching you guys,and I'm happy to answer questions at any time.So let's talk about the straightforward algorithm.The straightforward algorithm is somethingthat starts from the left and just walks across.And you might have something that looks like that.All right?By that-- By this I mean the numbers are increasingas you start from the left, the peak is somewherein the middle, and then things start decreasing.Right?So in this case, you know, this might be the peak.You also may have a situation wherethe peak is all the way on the right,you started from the left.And it's 1, 2, 3, 4, 5, 6, literallyin terms of the numbers.And you're going to look at n elements going all the wayto the right in order to find the peak.So in the case of the middle you'dlook at n over 2 elements.If it was right in the middle.And the complexity, worst case complexity----is what we call theta n.And it's theta n, because in the worst case,you may have to look at all n elements.And that would be the case where you started from the leftand you had to go all the way to the right.Now remember theta n is essentially somethingthat's says of the order of n.So it gives you both the lower bound and an upper bound.Big [? O ?] of n is just upper bound.And what we're saying here is, we'resaying this algorithm that starts from the leftis going to, essentially, require in the worst casesomething that's a constant times n.OK?And you know that constant could be 1.You could certainly set things up that way.Or if you had a different kind of algorithm,maybe you could work on the constant.But bottom line, we're only concerned, at this moment,about as asymptotic complexity.And the asymptotic complexity of this algorithm is linear.All right?That make sense?OK.So someone help me do better.How can we do better?How can we lower the asymptotic complexityof a one dimensional peak finder?Anybody want to take a stab at that?Yeah?Back there.AUDIENCE: Do a binary search subset.You look at the middle, and whateveris higher-- whichever side is higher, then cut that in half,because you know there's a peak.PROFESSOR: On--AUDIENCE: For example if you're in the middleon the right side-- there's a higher numberon the right side-- then you would justlook at that, because you know that your peak's somewherein there.And you continue cutting in half.PROFESSOR: Excellent!Excellent!That's exactly right.So you can-- You can do something different, whichis essentially try and break up this problem.Use a divide and conquer strategy, and recursively breakup this one dimensional array into smaller arrays.And try and get this complexity down.Yeah?AUDIENCE: Are we assuming that there's only one peak?PROFESSOR: No, we're not.AUDIENCE: OK.PROFESSOR: It's find a peak if it exists.And in this case it's, "find a peak",because of the definition.We don't really need this as it was discussed.All right?OK.So--So that was a great answer, and-- You know this classafter while is going to get boring.Right?Every class gets boring.So we, you know, try and break the monotony here a bit.And so-- And then the other thing that we realizedwas that these seats you're sitting on-- thisis a nice classroom-- but the seats you're sitting onare kind of hard.Right?So what Eric and I did was we decidedwe'll help you guys out, especially the oneswho are-- who are interacting with us.And we have these--[LAUGHTER]--cushions that are 6.006 cushions.And, you know, that's a 2 by 2 by 2 Rubik's cube here.And since you answered the first question, you get a cushion.This is kind of like a Frisbee, but not really.So--[LAUGHTER]I'm not sure-- I'm not sure I'm going to get it to you.But the other thing I want to sayis this is not a baseball game.Right?Where you just grab the ball as it comes by.This is meant for him, my friend in the red shirt.So here you go.Ah, too bad.All right.It is soft.So, you know, it won't-- it won't hurt you if hits you.