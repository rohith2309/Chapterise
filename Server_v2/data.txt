hello and welcome to the kubernetescrash course where i will teach youeverything you need to know to getstarted with kubernetes in one houri am nana and i have taught hundreds ofthousands of people how to advance theirdevops skills through my youtube channelonline courses and the devopseducational programif you're new here be sure to subscribebecause i upload new videos all the timenow let's look at an overview of whatyou will learnfirst of all we'll see what iskubernetes and why do we need it and whydid it become so popularsecond we will go through the kubernetesarchitecture and you will see howkubernetes actually works in thebackgroundafter that we will cover main kubernetescomponents that you need to learn towork efficiently with kubernetes andfinally we will do a hands-on demoproject to get your first practicalexperience with kubernetes nowkubernetes is a very popular but also avery complex technology so this crashcourse will help you get your firstexperience to get started withkubernetes but if by the end of thevideo you decide to deepen yourknowledge in kubernetes and are thinkingabout a career as a kubernetesadministrator my new complete kubernetesadministrator course will be a greatresource for you where you will learnhow to build configure and managekubernetes clusters from scratchthe course is also dedicated to help youpass the cka exam from linux foundationto become a certified kubernetesadministrator now we have a lot to coverin this video so let's jump right intoitso let's jump in right into thedefinition what is kubernetesso kubernetes is an open sourcecontainer orchestration framework whichwas originally developed by google so onthe foundation it manages containers bedocker containers or from some othertechnology which basically means thatkubernetes helps you manage applicationsthat are made up of hundreds or maybethousands of containers and it helps youmanage them in different environmentslike physical machines virtual machinesor cloud environments or even hybriddeployment environmentsso what problems does kubernetes solveand what are the tasks of a containerorchestration tool actually so to gothrough this chronologicallythe rise of microservices causedincreased usage of containertechnologies because the containersactually offer the perfect host forsmallindependent applications likemicroservicesand the rise of containers and the microservice technology actually resulted inapplications they're now comprised ofhundreds or sometimes maybe eventhousands of containers managing thoseloads of containers across multipleenvironments using scripts and self-madetools can be really complexand sometimes even impossible so thatspecific scenario actually caused theneed forhaving container orchestrationtechnologiesso what those orchestration tools likekubernetes do isactually guarantee following featuresone is high availability in simple wordshigh availability means that theapplication has no downtime so it'salways accessible by the users a secondone is scalability which means you canscale your applications fast when youhave more load on it and more users aretrying to access it and the same way youcan easily scale it down when the loadgoes downso it makes your application moreflexible to adjust to the increasing ordecreasing load and the third one isdisaster recovery which basically meansthat if an infrastructure has someproblems like data is lost or theservers explode or something bad happenswith the service center theinfrastructure has to have some kind ofmechanism to back up the data and torestore it to the latest state so thatapplication doesn't actually lose anydata and the containerized applicationcan run from the latest state after therecoveryand all of these are functionalitiesthatcontainer orchestration technologieslike kubernetes offer so how does thekubernetes basic architecture actuallylook likethe kubernetes cluster is made up withat least one master nodeand then connected to it you havea couple of worker nodes where each nodehas a cubelet process running on it andcubelet is actually a kubernetes processthat makes it possible for the clusterto talk to each other to communicate toeach other and actually execute sometasks on those nodes like runningapplication processeseach worker node has containers ofdifferent applications deployed on it sodepending on how the workload isdistributed you would have differentnumber of docker containers running onworker nodes and worker nodes are wherethe actual work is happening so here iswhere your applications are running sothe question is what is running onmasternodemasternode actually runs severalkubernetes processes that are absolutelynecessaryto run and manage the cluster properlyone of such processes is an api serverwhich also is a container an api serveris actually the entry point to thekubernetes cluster so this is theprocesswhich the different kubernetes clientswill talk to like ui if you're usingkubernetes dashboard an api if you'reusing some scripts and automatingtechnologies and a command line tool soall of these will talk to the api serveranother process that is running onmaster node is a controller managerwhich basically keeps an overview ofwhat's happening in the cluster whethersomething needs to be repaired or maybeif a container died and it needs to berestarted etcand another one isscheduler which is basically responsiblefor schedulingcontainers on different nodes based onthe workload and the available serverresources on each node so it's anintelligentprocess that decides on which workernode the next container should bescheduled on based on the availableresources on those worker nodes and theload that that container needs andanother very important component of thewhole cluster is actually an etcd keyvalue storage which basically holds atany time the current state of thekubernetes cluster so it has all theconfiguration data insideand all the status data of each node andeach container inside of that node andthe backup and restore that we mentionedpreviously is actually made from theseetcd snapshots because you can recoverthe whole cluster state using that etcdsnapshot and last but not least also avery important component of kuberneteswhich enables those nodes worker nodesmasternodes talk to each other is thevirtual network that spans all the nodesthat are part of the cluster and insimple words virtual network actuallyturnsall the nodes inside of a cluster intoone powerful machine that has the sum ofall the resources of individual nodesone thing to be noted here is thatworker knows because they actually havemost load because they are running theapplications on inside of it usually aremuch bigger and have more resourcesbecause they will be running hundreds ofcontainers inside of them whereas masternode will be running just a handful ofmaster processes like we see in thisdiagram so it doesn't need that manyresources however as you can imaginemasternode is much more important thanthe individual worker nodes because iffor example you lose a masternode accessyou will not be able to access thecluster anymore and that means that youabsolutely have to have a backup of yourmaster at any time so in productionenvironments usually you would have atleast two masters inside of yourkubernetes cluster but in more cases ofcourse you're going to have multiplemusters where if one muster nodeis down the cluster continues tofunction smoothly because you have othermasters availablein this video we're going to learn aboutthe main kubernetes components that weas kubernetes administrators or userswill be working with most of the time tomake it easier to understand all thesecomponents i'm gonna build a simple usecase of a web application with a simpledatabase and i'm gonna show you step bystep how each component in kuberneteshelps you deploy such an applicationsetup and what is the role of each ofthese componentsso let's start with the basic setup of aworker node or in kubernetes terms anodewhich is a simple server a physical orvirtual machine and the basic componentor the smallest unit of kubernetes is apod so what pod is is basically anabstraction over a container so ifyou're familiar with docker containersor container images so basically whatpod does is it creates this runningenvironment or a layer on top of thecontainerand the reason is because kuberneteswants to abstract away the containerruntime or container technologies sothat you can replace them if you want toand also because you don't have todirectly work with docker or whatevercontainer technology you use in akubernetes so you only interact with thekubernetes layer so we have anapplication pod which is our ownapplication and that will maybe use adatabase pod with its own container andthis is also an important concept herepod is usually meant to run oneapplication container inside of it youcan run multiple containers inside onepod but usually it's only the case ifyou have one main application containerand the helper container or some sideservice that has to run inside of thatpodand as you see this is nothing specialyou just have one server and twocontainers running on it with aabstraction layer on top of it so nowlet's see how they communicate with eachother in kubernetes world so kubernetesoffers out of the box a virtual networkwhich means that eachpod gets its own ip address not thecontainer the pod gets the ip addressand each podcan communicate with each other usingthat ip address which is an internal ipaddress obviously it's not the publicone so my application container cancommunicate with database using the ipaddress however pod components inkubernetes also an important concept areephemeral which means that they can dievery easilyand when that happens for example if ilose a database container because thecontainer crashed because theapplication crashed inside or becausethe nodes the server that i'm runningthem onran out resources the pod will dieand a new one will get created in itsplace and when that happens it will getassigned a new ip address whichobviously is inconvenient if you arecommunicating with the database usingthe ip address because now you have toadjust it every time pod restarts andbecause of that another component ofkubernetes called service is usedso service is basically a static ipaddress or permanent ip address that canbe attached so to say to each pod so myapp will have its own service anddatabase pod will have its own serviceand the good thing here is that the lifecycles of service and the pod are notconnected so even if the pod diesthe service and its ip address will stayso you don't have to change thatendpoint anymoreso now obviously you would want yourapplication to be accessible through abrowser right and for this you wouldhave to create an external service soexternal services a service that opensthe communication from external sourcesbut obviously you wouldn't want yourdatabase to be open to the publicrequests and for that you would createsomething called an internal service sothis is a type of a service that youspecify when creating one however if younotice the url ofthe external service is not verypractical so basically what you have isan http protocol with a node ip addressso of the node not the service and theport number of the service which isgood for test purposes if you want totest something very fast but not for theend product so usually you would wantyour url to look like this if you wantto talk to your application with asecure protocol and a domain name andfor thatthere is another component of kubernetescalled ingress so instead of service therequest goes first to ingress and itdoes the forwarding then to the serviceso now we saw some of the very basiccomponents of kubernetes and as you seethis is a very simple setup we just havea one server and a couple of containersrunning and some services nothing reallyspecial where kubernetes advantages orthe actual cool features really comeforward but we're gonna get there stepby step so let's continueso as we said pods communicate with eachother using a service so my applicationwill have a database endpoint let's saycalled mongodb service that it uses tocommunicate with the database butwhether you configure usually thisdatabase url or endpoint usually youwould do it in application propertiesfile or as some kind of externalenvironmental variable but usually it'sinside of the built image of theapplication so for example if theendpoint of the service or service namein this case changed to mongodb youwould have to adjust that url in theapplication so usually you'd have torebuild the application with a newversion and you have to push it to therepository and now you'll have topull that new image in your pod andrestart the whole thing so a little bittedious for a small change like databaseurl so for that purpose kubernetes has acomponent called config map so what itdoes is it's basically your externalconfiguration to your application soconfig map would usually containconfiguration data like urls of adatabase or some other services that youuse and in kubernetes you just connectit to the pod so that pod actually getsthe data that config map containsand now if you change the name of theservice the endpoint of the service youjust adjust the config map and that's ityou don't have to build a new image andhave to go through this whole cycle nowpart of the external configuration canalso be database username and passwordright which may also change in theapplication deployment process butputting a password or other credentialsin a config map in a plain text formatwould be insecure even though it's anexternal configuration so for thispurpose kubernetes has another componentcalled secretso secret is just like config map butthe difference is that it's used tostore secret data credentials forexample and it's stored not in a plaintext format but in base 64 in encodedformat but of course basics beforeencoding a secret doesn't make itautomatically securethe secret components are meant to beencryptedusing third-party tools in kubernetesbecause kubernetes doesn't encrypt themout of the boxand there are tools for that from cloudproviders or separate third-party toolsthat you candeploy on kubernetes to encrypt yoursecrets and that will make secretssecureso secret would contain things likecredentials and of course i meandatabase user you could also put inconfig map but what's important is thepasswords certificates things that youdon't want other people to have accessto would go in the secret and just likeconfig map you just connect it to yourpod so that pod can actually see thosedata and read from the secret you canactually use the data from configmap orsecret inside of your application podusing for example environmentalvariables or even as a properties fileso now let's see another very importantconcept generally which is data storageand how it works in kubernetesso we have this database pod that ourapplication uses and it has some data orit generates some data with this setupthat you see now if the databasecontainer or the pod gets restartedthe data would be gone and that'sproblematic and inconvenient obviouslybecause you want your database data orlog data to be persisted reliably longtermand the way you can do it in kubernetesis using another component of kubernetescalled volumesand how it works is that it basicallyattaches a physical storage on a harddrive to your pod and that storage couldbe either on a local machine meaning onthe same server node where the pod isrunning or it could be on a remotestorage meaning outside of thekubernetes cluster it could be a cloudstorage or it could be your own premisestorage which is not part of thekubernetes cluster so you just have anexternal reference on it so now when thedatabase pod or container gets restartedall the data will be there persistedit's important to understand thedistinction between the kubernetescluster and all of its components andthe storageregardless of whether it's a local orremote storage think of a storage as anexternal hard drive plugged in into thekubernetes cluster because the point iskubernetes cluster explicitly doesn'tmanage any data persistence which meansthat you as a kubernetes user or anadministrator are responsible forbacking up the data replicating andmanaging it and making sure that it'skept on a proper hardware etc becauseit's not taking care of kubernetesso now let's see everything is runningperfectly and a user can access ourapplication through a browsernow with this setup what happens if myapplication pod dies right crashes or ihave to restart the pod because i builta new container imagebasically i would have a downtime wherea user can reach my application which isobviously a very bad thingif it happens in production and this isexactly the advantage of distributedsystems and containersso instead of relying on just oneapplication part and one database partetcwe are replicating everythingon multiple serversso we would have another node where areplica or clone of our applicationwould run which will also be connectedto the service so remember previously wesaid the service is like a persistentstatic ip address with a dns name sothat you don't have toconstantly adjust the end point when apod diesbut service is also a load balancerwhich means that the service willactually catch the request and forwardit to whichever part is least busy so ithas both of these functionalitiesbut in order to create the the secondreplica of the my application pod youwouldn't create a second part butinstead you will define a blueprint fora my application pod and specify howmany replicas of that pod you would liketo run and that component or thatblueprint is called deployment which isanother component of kubernetes and inpractice you would not be working withpods or you would not be creating podsyou would be creating deploymentsbecause there you can specify how manyreplicas and you can also scale up orscale down the number of replicas ofpots that you need so with pot we saidthat pot is a layer of abstraction ontop of containersand deployment is another abstraction ontop of pots which makes it moreconvenient to interact with the podsreplicate them and do some otherconfigurationso in practice you would mostly workwith deployments and not with pods sonow if one of the replicas of yourapplication pod would die the servicewill forward the requests to another oneso your application would still beaccessible for the user so now you'reprobably wondering what about thedatabase pod because if the databasepart died your application also wouldn'tbe accessible so we need adatabase replica as well however wecan't replicate database using adeployment and the reason for that isbecause database has a state which isits datameaning that if we have clones orreplicas of the database they would allneed to access the sameshareddata storage and there you would needsome kind of mechanism that manageswhich parts are currently writing tothat storage or which pods are readingfrom the storage in order to avoid datainconsistencies and that mechanismin addition to replicating feature isoffered by another kubernetes componentcalled statefulset so this component ismeant specifically for applications likedatabases so mysql mongodbelasticsearch or any other statefulapplications or databasesshould be created using stateful setsand not deploymentsit's a very important distinctionand stateful said just like deploymentwould take care ofreplicating the pots and scaling them upor scaling them down but making sure thedatabase reads and writes aresynchronized so that no databaseinconsistencies are offered however imust mention here that deployingdatabase applications using statefulsetsin kubernetes cluster can be somewhattedious so it's definitely moredifficult than working with deploymentswhere you don't have all thesechallenges that's why it's also a commonpractice to host databaseapplications outside of the kubernetescluster and just have the deployments orstateless applicationsthat replicate and scale with no probleminside of the kubernetes cluster andcommunicate with the external databaseso now that we have two replicas of myapplication pod and two replicas of thedatabase and they're both load balancedour setup is more robust which meansthat now even if node one the whole nodeserver was actually rebooted or crashedand nothing could run on it we wouldstill have a second node withapplication and database pods running onit and the application would still beaccessible by the user until these tworeplicas get recreated so you can avoiddowntimeso to summarize we have looked atthe most used kubernetes components westart with the pods and the services inorder to communicate between the partsand the ingress component which isused to route traffic into the clusterwe've also looked at externalconfiguration using config maps andsecrets and data persistence usingvolumes and finally we've looked at podblueprints with replicating mechanismslike deployments and stateful sets wherestateful set is used specifically forstateful applications like databasesjust using these core components you canactually build pretty powerfulkubernetes clustersbefore moving on i want to give a shoutout to castin who made this videopossiblekessen's k10 is the data managementplatform for kubernetesk10 basically takes off most of the loadof doing backup and restore inkubernetes from the clusteradministrators it has a very simple uiso it's super easy to work with and hasan intelligent logic which does all theheavy lifting for you and with my linkyou can download k10 for free and get 10nodes free forever to do your kubernetesbackups so make sure to check out thelink in the video description and nowlet's continueso now that we have seen the basicconcepts of kubernetes how do weactually create those components likepods and services to configure thekubernetes clusterall the configuration in kubernetescluster actually goes through a masternode with the process called api serverwhich we mentioned briefly earlier sokubernetes clients which could be a ui akubernetes dashboard for example or anapi which could be a script or a curlcommandor a command line tool like cubectl theyall talk to the api server and they sendtheir configuration requests to the apiserver which is the main entry point orthe only entry point into the clusterand these requests have to be either inyaml format or json format and this ishow example configuration in yaml formatactually looks like so with this we aresending a request to kubernetes toconfigure a component called deploymentwhich is basically a template or ablueprint for creating pods and in thisspecific configuration example we tellkubernetes to create two replica podsfor us called my app with each podreplica having a container based on myimage running inside in addition to thatweconfigure what the environment variablesand the port configuration of thiscontainer inside of the pod should beand as you seetheconfiguration requests in kubernetes aredeclarative form so we declare what isour desired outcome from kubernetesand kubernetes tries to meet thoserequirements meaning for example sincewe declare we want two replica parts ofmy app deployment to be running in thecluster and one of those parts dies thecontroller manager will see that theease and shoot states now are differentthe actual state is one part our desiredstate is 2 so it goes to work to makesure that this desired state isrecovered automatically restarting thesecond replica of that podso here i have examples of a deploymentand service configuration files side byside so the first thing is that everyconfiguration file in kubernetes hasthree parts the first part is where themetadata of that component that you'recreating resides and one of the metadatais obviously name of the componentitself the second part in theconfiguration file is specification soeach component's configuration file willhave a specification where you basicallyput every kind of configuration that youwant to apply for thatcomponent the first two lines here asyou see is justdeclaring what you want to create herewe are creating deployment and herewe're creating a serviceand this is basically you have to lookup for each component there's adifferent api versionso now inside of the specification partobviously the attributes will bespecific to the kind of a component thatyou're creating so deployment will haveits own attributesthat only apply for deployment and theservice will have its own stuff but isaid there are three parts of aconfiguration file andwe just see metadata and thespecification so where's the third partso the third part will be a status butit's going to be automatically generatedand edit by kubernetes so the way itworks is that kubernetes will alwayscompare what is the desired state andwhat is the actual state or the statusof that component and if the status anddesired state do not match thenkubernetes knows there's something to befixed there so it's gonna try to fix itand this is the basis of theself-healing feature that kubernetesprovides for example here you specifyyou want two replicas of nginxdeployment so when you apply this whenyou actually create the deployment usingthis configuration file that's whatapply means kubernetes will add here thestatus of your deployment and it willupdate that state continuously so forexample if a status at some point willsay just one replica is running thenkubernetes will compare that status withthe specification and we'll know thereis a problem there another replica needsto be created sap now anotherinteresting question here iswhere does kubernetes actually get thestatus data to automatically add here orupdate continuously that informationcomes from the icd remember the clusterbrain one of the master processes thatactually stores the cluster data so itcd holds at any time the current statusof any kubernetes component and that'swhere the status information comes fromso as you see the format of theconfiguration files is yemelthat's why the extension here andgenerally it's pretty straightforward tounderstand it's a very simple format butyaml is very strict about theindentations so for example if you havesomething wrongly indented here yourfile will be invalid but other than thatit's pretty simple another thing iswhere do you actually store thoseconfiguration files a usual practice isto store them with your code becausesince the deployment and service isgoing to be applied to your applicationit's a good practice to store theseconfiguration files in your applicationcode so usually it will be part of thewhole infrastructure as a code conceptor you can also have its own gitrepository just for the configurationfilesso in this video i'm going to show youwhat mini cube and cube ctl are and howto set them upso first of all let's see what is minicube usually in kubernetes world whenyou are setting up a production clusterit will look something like this so youwould have multiple masters at least twoin a production setting and you wouldhave multiple worker nodesand master nodes and the worker nodeshave their own separate responsibilityso as you see on the diagram you wouldhave actual separate virtual or physicalmachines that each represent a notenow if you want to test something onyour local environment or if you want totry something out very quickly forexample deploying new application or newcomponents and you want to test it onyour local machine obviously setting upa cluster like this will be prettydifficult or maybe even impossible ifyou don't have enough resources likememory and cpu etc and exactly for theuse casethere's this open source tool that iscalled a mini cube so what a mini cubeis is basically one node cluster wherethe master processes and the workerprocesses both run on one node and thisnode will have a docker containerruntime pre-installed so you will beable to run the containers or the podswith containers on this nodeso now that you have this virtual nodeon your local machine that representsmini cube you need some way to interactwith that cluster so you need a way tocreate podsand other kubernetes components on thenode and the way to do it is usingcubectl which is a command line tool forkubernetes cluster so let's see how itactually works remember we said thatminicube runs both master and workprocesses so one of the master processescalled api server is actually the mainentry point into the kubernetes clusterso if you want to do anything in thekubernetes if you want to configureanything create any component you firsthave to talk to the api server and theway to talk to the api server is throughdifferent clients so you can have a uilike a dashboard you can talk to itusing kubernetes apior a command line tool which is cubectland cubectl is actually the mostpowerful of all the three clientsbecause with cube cdl you can basicallydoanything in the kubernetes that you wantand throughout this video tutorialswe're going to be using cube ctl mostlyso once the cube ctl submits commands tothe api server to create componentsdelete components etc the work processeson minicube node will actually make ithappen so they will be actuallyexecuting the commands to create theparts to destroy the parts to createservices etc so this is the mini cubesetup and this is how cubectl is used tointeract with the cluster an importantthing to note here is that kipctl isn'tjust for minikube cluster if you have acloud cluster or a hybrid clusterwhatever cube ctl is the tool to use tointeract with any type of kubernetescluster setup so that's important tonote here so now that we know what minicube and cube ctl are let's actuallyinstall them to see them in practicenow let's see how to install and runmini cube there are many different waysdepending on your operating system andits architecture so the best way is toreference the official documentation andhere as you see minicube can run eitheras a container or a virtual machine andthese are the resource requirements torun minicube on your machine so makesure you have enough resources forinstallation you just select the correctdata for your machine in my case it'sgoing to be mac os with a home homebrewinstallationand with one simple brew installed minicube command i can basically installmini cubelike this and as you see the latest minicube version has been installed onceminicube is installed we want toactually start or create a mini cubeclusterwhich is also super easy as you seewe simply execute a mini cube startcommandhowever as i mentionedminicube must start either as acontainer or a virtual machine so weneed either a container or a virtualmachine tool installed on our laptop torun mini cube and this is going to bethe driver for mini cube and opening thedrivers pageyou see the list of supported driversfor linux mac os and windows and you seethat docker is actually the preferreddriver for running mini cube on alloperating systems now this may be alittle bit confusing because as you knowinside the kubernetes cluster we rundocker containers and it's important tonote here that mini cube insulationactually comes with docker alreadyinstalled to run those containers butdocker as a driver from minicube meansthat we are hosting minicube on ourlocal machine as a docker containeritself so we have two layers of dockermini cube running is a docker containerand inside mini cube we have dockerpackaged in minikube to run ourapplication containers and for hostingminicube on our machine we can usedocker so if you have docker alreadyinstalled on your machine you're all setup to start a mini cube clusterif not also not a problem you can easilyinstall it from hereso clicking on install docker link thiswill take me to docker hub where i havedocker desktop installation for windowsand macso i'm simply going to click inin my case docker desktop for mac andi'm gonna download and install dockerand once downloaded just install itdrag and drop into the applicationsfolderand now we can start the docker daemonfrom the applicationsand as you see docker is starting up sothe download and installation may takesome time but once docker is installedand running we can switch back to theterminal and start the mini cube clusterusing mini cubestart command passing docker as a driveroptionusing the driver flag with docker valueand let's executeand this may also take a while whenyou're running it first time because itneeds to actually create the cluster anddownload all the necessary images andcomponents so the next time you do minicube start it should actually go fasterand as you see this command created alocal kubernetes cluster on our machinewith the latest kubernetes version1.22 and now we can check the status ofthe cluster using minicubestatus commandand we see that all the componentsinside are running and everything isconfigured and now start to actuallyinteract with our cluster usingcommand line tool and cubectl actuallygets installed as a dependency when weinstall minicubewhich you see right here installingdependencies for minicube and kubernetescli is actually cube ctland that means we already have thatavailable we don't have to install it sonow i can do cube ctl get nodeand this will display all the nodes inthe cluster in our case we just have onenode which is control plane and theworker node at the same timeand we see information for each nodelike the status the kubernetes versionthat it's running as well as when it wasadded to the cluster so with this we nowhave an actual kubernetes clusterrunning locally on our machine and wecan start deploying applications in itso from this point on we are going to beinteracting with the mini cube clusterusing cubectl command line tool sominicube is basically just for thestartup and for deleting the cluster buteverything else configuring we're goingto be doing through cubectl now we haveenough knowledge to deploy a very simplebut realistic application setup in akubernetes cluster we will deploy amongodb database and a web applicationwhich will connect to the mongodbdatabase using external configurationdata from config map and the secret andfinally we will make our web applicationaccessible externally from the browserso let's get right in so i have tworesources here we're going to referencethe kubernetes documentation to createour components which is a realistic wayof working with kubernetes and also adocker hub where i havethe web application image that i createdwhich is publicly accessible so you canalso pull it directly from the dockerhub in your kubernetes cluster so firstlet's go ahead and createall the kubernetes configuration filesthat we need for deploying ourapplication setup and for that i'm goingto go to visual studio code where i havea kubernetes demo folder open and inthis folder we're going to create fourkubernetes configuration files that weneed we're going to create a config mapwith mongodbdatabase endpoint we're going to createa secret with username and password formongodb and then we're going to create aconfiguration file for deploying amongodb applicationand its service and then we're going tocreate kubernetes configuration file fordeploying our simple demo appapplication with its serviceso the first file will be calledconfig.ymland creating a config map in kubernetesis super simple for the syntax we canreference kubernetes documentationso i'm going to copy the first part herepaste it inand that's basically the main syntaxwe're starting fromlet's call our config mapconfigso we have the metadata and then we havethe actualcontents of this config map within thedata attribute we have all the key valuepairs that we define as externalconfiguration within this config map inour case we just have one which we'regoing to callurl as a key and of course we need avalue for the mongodb url and the valuewill be the service that we're going tocreate for mongodb application and we'regoing to call that serviceserviceand in a couple of minutes you're goingto see how to create this serviceand that will be basically all theconfiguration we need for creatingconfig mapso that one is done let's now go aheadand create secretdotyaml which will hold the username andpassword for mongodb application againto referencedocumentationi'm going to take this one and let'sactually copy the whole thingso we have the secret kind instead ofconfig map let's call this secretwe have type opaque which is the generictype for defining secret data basicallyand we have the same data attribute hereand let's actually create our own valueslet's call this[Music]userandpasswordand as you already learned the values insecret are base64 encoded so we can justset the values plain text we have toencode them first and encoding values issuper easy we're just gonna do echoand let's call it userandbase 64. encode itand the same way let's dopasswordandpaste those valuesand this will be our secretconfiguration and now when we createdeployments for our applications we canreferenceany of the values defined in the secretor config map so let's see how thatworksagain let's create a new file and let'scall this dot yaml this is goingto be a configuration file wherewe're going to create deployment andservice for mongodb you can haveseparate files for them but it's a verycommon thing to put them togetherbecause all the deployments needservices so you have them grouped in oneyaml fileand againlet's reference the documentation forthe deployment example syntaxand we can then adjust the values as weneedand as you see deployment configurationfile looks a little bit more complexthan configmap or a secret so let's gothrough the configuration and understandall these attributes so we have themetadata sectionand the specification and these arebasically deployment specificconfiguration that we have in thespecification section and let's startwith the main part of the deploymentwhich defines the blueprint for the potsand that blueprint is defined as atemplate so templatebasically is a configuration of the partwithin the configuration of deploymentand you see that template section hasits own metadata and own spec orspecification just like deployment hasits metadata and specification right sothis part actually configures the podwithin a deployment and in thespecification of the pod we have thedefinition of containers so this is alist of containers as you learned youcan have multiple containers in a potbut mostly one main application per potand this is where we define which imagewill be used to create this pod in ourcase this is going to be a mongodb imageand if wesearch for in docker hubthat's basically the image name and youcan find all the textin the text section and we're going touse the tag 5.0so one go5.0 that's where we define the imageof the container within the pot we canname thismongodb this is just the name of thecontainer and we also have the portwhere the container will listen andlet's check our image and as you seemongodb starts at this port so we canjust copy it and paste it in here sothis basicallyjust configures our deployment to createpods with a mongodb image version5.0 so that's the core of a deploymentnow let's see what is all this otherstuff here first of all we have thislabels attribute in the metadata sectionand then we also have match labelsattribute so what is this about inkubernetes you can give any componenta key value pair labels so you can labelanything from pod to deployment toconfigmap etc and labels basically areadditional identifiers of the componentsin addition to the name for exampleso you canidentify and address specific componentsusing their labelsnow why do we need them first of allwhen we have multiple replicas of thesame parteach part will get a uniquename howeverthey can share the same label so we canidentify all the part replicas of thesame application using a specific labelthat all of them share and that's why inthe metadata of the pod we always havethis label so for pods labels is arequired field for other components likedeployment configmap etc labels isoptional but it is a good practice toset themnowwhen we create pod replicas how doesdeployment know which parts actuallybelong to it or how does kubernetes knowwhich pods belong to which deploymentsand that is defined usingthis part right here soselector match labels is in thespecification of the deployment as yousee and this definesthat all the parts that matchthis label belong tothis deployment so that's why we havematch labels hereso thisselector will match the pods createdwith this configurationbecause they have label app engine x noware these labelsgiven or can you select any key valuepairs well these are totally up to youyou can call it whatever you wantyou can call it my keymy value it doesn't really matterhowever the standard and a commonpractice in kubernetes is to use appkey in the labels when labeling yourapplications and the value willobviously be whatever application youhave so let's actually change and setthe valuesto instead of nginxbecause that's our application and ofcourse we want to match label appand let's also changethis one right hereto deployment and finally lastattribute we have here is replicas whichis super simple and straightforward thisjust defines how many pods you want tocreate using this blueprint in our caselet's do just one replica because it's adatabase and as you learned if you wantto scale databases in kubernetes youshould use stateful set and not adeployment to keep everything simplewe're going to stick to one replica andthat basically configures our mongodbdeploymentand the pod blueprint now let's add aservice configuration because everyapplication needs a service inkubernetes andthat's going to be a separateyamlunit or yaml section and we're going toseparate it usingthree dashes which is basic yaml syntaxnothing specific to kubernetes and againlet'sgrab a service exampleand adjust it as we need now serviceconfiguration is much easier than thedeployment as you see first let's changethe name let's call it service andremember this is the end pointwhichwe will use to access and that'swhat we defined right here so this isthe name of the serviceand in the specification we haveservice specific attributes first of allwe have the selector attribute which youalready know from here now why do weneed a selector in service because asyou know service needs to forward therequest that it gets toits endpoint pods how does service knowwhich pods belong to it and which onesit should forward the requests to wellusing the same label selector as we sawon deployment so this should matchthe labelof the pods that will belong to theservice which is and that's how service and podswill find each other and then we havethe ports configuration which is alsosuper simple service is accessiblewithin the cluster using its own ipaddress and the port and we define itsport right hereand this can be any port that we decideon this could be 80 8080 doesn't reallymatterand we have the target port which is theport of the pods that belong to theservice and logically enough the targetport should always be the same as thecontainer port because that's where theapplication in the pod is accessiblethat's where the service should forwardthe request to so again very importantport attribute sets the port of theservice and target port tells serviceto which port it should forward therequest to the pods and this should besame as the container port port andtarget port values can be different oragain it's a common standardtoselect the same port for the service aswell just to keep things simple so let'ssave this and that's our configurationfor mongodb deployment and servicenow i'm going to copy this whole thingandcreatea deployment in service for webapplication for our kubernetes demoapplication and let's call this webappdot yamlpasteeverything inand we can just adjust all thesevaluesin the serviceand deploymentall the labels and label selectors ofcourseand right here we of course need thecorrect image of our web applicationgoing back to our docker hubthis isthe name of my image and again this ispublicly accessible so you can use it aswellandthe tag is v1.0and there you go so this is a verysimple node.js application which startson port 3000 so that's why we need todefine container port on 3000 andcontainer port is same as target porton the service and we can set theservice port to the same value and thiswill configuredeploymentandservice for our web applicationso this isthe basic configuration for deploymentand service for any application inkubernetes clusterbut we have one more thing to configurein our deployment components for both and web app which is we need topass the data defined in the config andsecret componentsfirst of all when starting a mongodbapplication we need to set user name andpassword so when mongodb applicationstarts it will automatically generateusername and password for mongodb and wecan then use that to access it in ourclusternow how do we knowhow username and password can beconfigured in a mongodb on startup wellwe go to the image documentation andright here we see the environmentvariable namesfor username and password and these areactually required fields in most of thedatabases we have to set them otherwisewe won't be able to access them so thenext question is how do we configureenvironment variables in a containerconfiguration so how do we passenvironment variables to thisapplication running inside the containerwell that's also very easy we have nattribute for thatwhich is a list of environment variableswith namesandvalues that's itsovery simple so name is the environmentvariable name and value isthe environment variable value so let'scopy the nameso this is the environment variable namethat mongodb expects and we have to seta value whatever we want the username tobe now we can directly setthe username right here like thisor in our case we're going to referencethem from secret and configcomponentshow do we do that also pretty simple wedo value fromand we want to reference itfrom the secret so we do secretkeyrefand under that we have the name of thesecretwhich we called secretand the keywhich is userso kubernetes will basically find asecret with this nameand get the value set for this key andsubstitute it as a value for thisenvironment variable and the same waywe're gonnaconfigurea passwordso let's take the password that's thename of the environment variablesame secretscomponentthis time with a different keyand that's itso our mongodb configuration file iscompleteand when it starts a user with thesecredentials will be createdwhen our web application starts it willneed to connect to the database so weneed to give this web applicationinformation about the database endpointwhere can it access the databaseand which username and password to useto authenticate with the database and ihave already configured this applicationinside to expect all these values asenvironment variables with specificnames so we're going to passthese three pieces of data asenvironment variablesto the web app application so let's dothatagainthe name of the environment variable thefirst one i actually called usernameand we can actually copythe same configuration and paste it hereand you already see an advantage ofusingconfiguration from secret or configbecause if you need the same informationin 10 different applications you createit once and reference it 10 timesthe secondenvironment variable is for passwordand i called this one user pwdand finally our application needsthe database endpoint whichwill be db urland this value is not in the secretbut in configmap and how do we accessvalue from config map very similar asthe secret so we have the same valuefromand instead of secret key ref we haveconfigmapkirevor key referenceand then we havename which we called configand keywhich is the name of the keyand that's it so we don't have any ofthe configuration values hard coded inourkubernetes configuration files we onlyhave references which makes ourconfiguration way cleaner so ifsomething changes or the values changehere we don't have to adjust anything inour deploymentsso connectivity with the database isconfigured and there is one last thingmissing in our web applicationconfiguration before we deploy all thiswhich is making it accessible from thebrowser we want to be able to type insome url and access our web applicationfrom the browser right and as youlearned we have external services forthat so we will need to adjustthe service configuration a little bitright nowthese service configurations both ofthem are internal servicesso to make it externalall we need to do isset a type which is by default clusteripso that's the default type if we don'tspecify the type but we're going to setit tonode portso node port is an external service typeand it requires a third port which iscalleda node portso what is a node port portthis is a port which will open on thekubernetes nodes on which theapplication will be accessible so on thenode ip address in node port combinationwe will be able to accessthis service which will then accessthe pods behind it and node port rangeis actually defined in kubernetes so wecan't just type anything we want herelike this it has to be within the rangeof thirty thousand and thirty twothousand seven hundred sixty seven soanything within this range is fine as avalue so we can do 30 000 or 30100 doesn't really matterso let's set this as a value and thiscompletes the web app configuration filenow we have a very simple but alsopretty realisticconfigurationfor deploying an application with itsdatabasewith external configuration in thecluster so as a final step we're justgonna create all these components one byone in kubernetes so i'm gonna open aterminal and we already have a mini cubecluster runningbut there are no components inside sofirst we need to create the externalconfigurations becausethey need to be there when we createmongodb and web application deploymentsbecause they reference thoseconfigurations so let's create config and secret first to do thatwe have cube ctl apply command withminus f which stands for file whichtakes a kubernetes configuration file asan inputlike thisand creates whatever is defined insideand as you see config was creatednow let's create longer secretnext we're gonna create a databasebecause our web application depends onitso it should start firstand again let's do cube ctl applywith mongo.yaml as an input and as yousee deploymentand service were created and finallylet's deploy our web application andthere you go so everything seems finebut of course we want to check all theparts and all the componentsthat were created in the clusterso for that i'm going to actually switchto command line so that we can see itbetterand first we're going to do cube ctl getallwhich gives you all the componentscreated in the cluster which includesdeploymentsthe podsbehind the deployment and all theservices and as you see we havedeployment and web app deployment partseach one with one replica running and wehave the services formongodb and web appand web app service is of node port typewhich means we can access it externallyhowever we don't see configmap andsecret here we can get them usingkubectl get config mapand cubectl getsecret commands so as you see displayingany component is pretty easy using cubectl you just do kubectl get and the nameof the component like pod and you geta list of those componentswith some additional dataand cubesatl is actually a very powerfultool and it has a bunch of sub-commandsso as a natural documentation forcubectl to basically have an overviewand see what you can do with it you canalways use cubectlhelp as a documentation which lists allthe sub-commands you can use with it oneof them which we already usedget and for each sub-commandlike cube ctl get you can also get somehelpand basically see all the examplesplus all the available options so youcan navigate all the options you havehere so cube ctl get is obviously themost common command you're going to useto list all the componentsif you want to see more details about acertain componentyou can use cube ctl describe commandfor it a name of the component like aservice for exampleand the actual instance of thatcomponent like web app service and thiswill give you more detailed output aboutthat specific component same way you canalso do cube ctl describe pod and thenname of the podlike this oneand this will give you details aboutyour pot including the status of how thepod was scheduledthe container configurationlabels etcand finallyof course when you have applicationsrunning in your cluster you want tocheck the logs to troubleshoot debug orjust make sure that everything is finewithin the pod and you can do that veryeasily using kubectl locks commandand just specifying name of the pot likethisthis gives youlogs of the container insideand you can even stream the logs usingminus f optionso the final step we want to validatethat our application is also accessiblefrom the browser and for that weactually configured the service and wecan actually get the service usingservice or svccomment so how do we access this servicefrom the browser because this is theport we're going to use to access it butwhich ip address is it accessible atwell the node port service is alwaysaccessible at the ip address of thecluster node so all the work nodes thatthe cluster has in our case we just haveone which is the mini cube so we needthe ip address of the mini cube to getthatwe just do mini cube ipor using kubernetes we can also getget node which gives you mini cubeanda white outputor a longer output than what you seeherewhich will give youthe ip addressof the node which is the same as thisone right here and by the way you canuse the all white option for any otherget command for services pods etc to getsome additional information like thisso let's grab the mini cube ip addressand access the application at this portwhich is 30100and there you go this is our webapplication which is connected tomongodb and we can also validate that byediting somethingand saving because this request goes todatabaseand if we refreshthe changes should still be thereawesome so we deployed an applicationwith its database in kubernetes which isa blueprint configuration for mostcommon applicationsetups you're gonna have plus you alsolearn a couple of cubesitl commands aswell as how to reference the kubernetesofficial documentation to help youconfigure and create all the componentsi hope i helped you learn a lot aboutkubernetes with this crash course andyou feel much more confident withkubernetes now if you're serious aboutlearning kubernetes in depth i actuallyhave two more resources for youas i mentioned at the beginning if youwant to really become an expert inkubernetes and learn how to build andadminister a cluster from scratch thenmy complete kubernetes administratorcourse will be a perfect resource foryou but if your goal is rather to becomea devops engineer then our completedevops educational program will be thebest fit for you where during asix-month program you learn all thenecessary concepts and technologiesincluding kubernetes which you need toget started in devops or cloudengineeringif you're interested you can find thelinks in the video description below andwith thatthank you for watching and see you inthe next video